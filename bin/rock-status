#! /usr/bin/env ruby

def package_status(pkg)
    pkg_name =
        if pkg.respond_to?(:text_name)
            pkg.text_name
        else pkg.autoproj_name
        end

    result = [pkg_name, [], []]

    if !File.directory?(pkg.srcdir)
        Autoproj.warn "#{pkg.name} not checked out (expected to be in #{pkg.srcdir})"
        raise ArgumentError, "#{pkg_name} is not checked out yet"
    elsif !pkg.importer
        raise ArgumentError, "configuration error: #{pkg_name} has no VCS"
    elsif !pkg.importer.respond_to?(:status)
        raise ArgumentError, "the #{pkg.importer.class.name.gsub(/.*::/, '')} importer does not support status display"
    else
        status = pkg.importer.status(pkg)
        if status.uncommitted_code
            Autoproj.warn "the #{pkg_name} package contains uncommitted modifications"
        end

        case status.status
        when Autobuild::Importer::Status::UP_TO_DATE
            result[0] = "#{pkg_name}: in sync"
        else
            result[1] = status.local_commits
            result[2] = status.remote_commits
        end
    end

    result
end
require 'autoproj'

webgen_output = false
dest_path = nil
parser = OptionParser.new do |opt|
    opt.banner = "rock-status from_flavor to_flavor"
    opt.on('--push-new', 'pushes new packages (creates a new branch for the target flavor') do
        push_new = true
    end
    opt.on('--webgen=FILE', 'generate a webgen-compatible page in FILE') do |path|
        webgen_output = true
        dest_path = path
    end
end
remaining = parser.parse(ARGV)

from_flavor = remaining.shift
to_flavor = remaining.shift

if !from_flavor || !to_flavor
    puts parser
    exit 1
elsif webgen_output && !dest_path
    puts parser
    exit 1
end

io = if webgen_output
         File.open(dest_path, 'w')
     else
         STDOUT
     end

ENV['ROCK_FORCE_FLAVOR'] = from_flavor
Autoproj::CmdLine.initialize_and_load(["--update"])
manifest = Autoproj.manifest
source_package_names = manifest.all_selected_packages.to_a
Autoproj::CmdLine.import_packages(source_package_names)

ENV['ROCK_FORCE_FLAVOR'] = to_flavor
Autoproj::CmdLine.initialize_and_load(["--update"])
manifest = Autoproj.manifest
target_package_names = manifest.all_selected_packages.to_a
target_packages = target_package_names.map do |pkg_name|
    Autobuild::Package[pkg_name]
end

if webgen_output
    io.puts "---"
    io.puts "title: Status - #{from_flavor} to #{to_flavor}"
    io.puts "---"
else
    io.puts
    io.puts
end

new_packages = (source_package_names - target_package_names)
if !new_packages.empty?
    title = "New packages: in #{from_flavor} but not in #{to_flavor}"
    if webgen_output
        io.puts "<h1>#{title}</h1>"
        io.puts "<ul>"
        new_packages.each do |pkg_name|
            io.puts "  <li>#{pkg_name}</li>"
        end
        io.puts "</ul>"
        io.puts
    else
        io.puts Autoproj.color(title, :bold)
        io.puts new_packages.join(", ")
    end
end

obsolete_packages = (target_package_names - source_package_names)
if !obsolete_packages.empty?
    title = "Obsoleted packages: in #{to_flavor} but not in #{from_flavor}"
    if webgen_output
        io.puts "<h1>#{title}</h1>"
        io.puts "<ul>"
        obsolete_packages.each do |pkg_name|
            io.puts "  <li>#{pkg_name}</li>"
        end
        io.puts "</ul>"
        io.puts
    else
        io.puts Autoproj.color(title, :bold)
        io.puts obsolete_packages.join(", ")
    end
end

in_from, in_to = 0, 0
errors, needs_push, needs_merge = [], [], []

status = target_packages.sort_by { |pkg| pkg.name }.map do |pkg|
    next if !source_package_names.include?(pkg.name)
    begin
        main, from_commits, to_commits = package_status(pkg)
    rescue Exception => status_error
        errors << pkg
        next([pkg, status_error])
    end

    if main
        in_from += from_commits.size
        if !from_commits.empty?
            needs_push << pkg
        end
        in_to += to_commits.size
        if !to_commits.empty?
            needs_merge << pkg
        end
    end
    [pkg, main, from_commits, to_commits]
end

if webgen_output
    result = []
    result << "<table class=\"package_status\">"
    status.each do |pkg, main, from_commits, to_commits|
        if main.kind_of?(Exception)
            status_error = main.message.gsub(/</, "&lt;").gsub(/>/, "&gt;").split("\n").join("<br/>\n")
            result << "<tr class=\"name\" id=\"#{pkg.name}\"><th class=\"error\">#{pkg.name}: failed to get status<br/><p class=\"error_message\">#{status_error}</p></th></tr>"
        else
            result << "<tr class=\"name\" id=\"#{pkg.name}\"><th>#{main}</th></tr>"
            if !from_commits.empty?
                result << "<tr class=\"from_commits\"><th>in #{from_flavor} but not in #{to_flavor}</th></tr>"
                from_commits.each do |line|
                    line = line.gsub(/</, "&lt;").gsub(/>/, "&gt;")
                    result << "<tr class=\"from_commits\"><td>#{line}</td></tr>"
                end
            end
            if !to_commits.empty?
                result << "<tr class=\"to_commits\"><th>in #{to_flavor} but not in #{from_flavor}</th></tr>"
                to_commits.each do |line|
                    line = line.gsub(/</, "&lt;").gsub(/>/, "&gt;")
                    result << "<tr class=\"to_commits\"><td>#{line}</td></tr>"
                end
            end
        end
    end
    result << "</table>"

    io.puts "<h1>Package status</h1>"
    io.puts "<p>#{in_from} commits in #{needs_push.size} packages are in #{from_flavor} and not pushed to #{to_flavor}<br/>"
    io.puts "Affected packages: #{needs_push.map(&:name).sort.map { |pkg_name| "<a href=\"##{pkg_name}\">#{pkg_name}</a>" }.join(", ")}</p>"

    io.puts "<p>#{in_to} commits in #{needs_merge.size} packages are in #{to_flavor} and not yet merged back to #{from_flavor}<br/>"
    io.puts "Affected packages: #{needs_merge.map(&:name).sort.map { |pkg_name| "<a href=\"##{pkg_name}\">#{pkg_name}</a>" }.join(", ")}</p>"

    io.puts "<p>#{errors.size} packages failed to fetch status: "
    io.puts "#{errors.map(&:name).sort.map { |pkg_name| "<a href=\"##{pkg_name}\">#{pkg_name}</a>" }.join(", ")}</p>"

    io.puts "  " + result.join("\n  ")
else
    status.each do |pkg, main, from_commits, to_commits|
        if main.kind_of?(Exception)
            io.puts Autoproj.color("failed to fetch #{pkg.name}", :bold)
            io.puts main.message
        else
            io.puts Autoproj.color(main, :bold)
            if !from_commits.empty?
                io.puts "in #{from_flavor} but not in #{to_flavor}"
                from_commits.each do |line|
                    io.puts "  #{line}"
                end
            end
            if !to_commits.empty?
                io.puts "in #{to_flavor} but not in #{from_flavor}"
                to_commits.each do |line|
                    io.puts "  #{line}"
                end
            end
        end
    end
end

